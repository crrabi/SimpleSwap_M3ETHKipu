# SimpleSwap: A Technical Deep Dive into a Minimalist AMM üí°

## 1. Project Overview üìú

**SimpleSwap** is a smart contract that provides core decentralized exchange (DEX) functionalities on the Ethereum blockchain. It is a single, self-contained contract designed for gas efficiency and code clarity, allowing users to swap ERC20 tokens, manage liquidity, and query on-chain data like prices and reserves.

This project was developed as an advanced exercise in Solidity, emphasizing not only the implementation of DeFi logic but also adherence to best practices and optimization patterns.

This document serves as a technical breakdown of the `SimpleSwap` contract architecture. It was developed with the assistance of a generative AI model, which helped in iterative debugging, code optimization, and the generation of this documentation.

---

## 2. Contract Architecture and Design üèõÔ∏è

### 2.1. Core Components

The `SimpleSwap` contract is composed of several key components that work together to provide its functionality:

-   **State Variables:**
    -   `totalSupply` (`mapping(bytes32 => uint256)`): Tracks the total amount of Liquidity Pool (LP) tokens for each unique token pair.
    -   `balanceOf` (`mapping(bytes32 => mapping(address => uint256))`): A nested mapping to track the LP token balance of each user for each pair.
    -   `_reserve0` / `_reserve1` (`mapping(bytes32 => uint112)`): Store the liquidity reserves of each token in a pair. These are private variables whose state is updated exclusively via trusted internal functions.

-   **Modifier:**
    -   `checkDeadline(uint deadline)`: A reusable modifier applied to time-sensitive functions (`addLiquidity`, `removeLiquidity`, `swapExactTokensForTokens`). It ensures that a transaction is not executed if it has been pending for too long, protecting users from unfavorable price changes.

-   **Interface Compliance:**
    -   The contract strictly adheres to the function signatures specified in the project requirements (`ISimpleSwap`), ensuring interoperability with external verifier contracts or front-end applications. The public functions match these specifications: `addLiquidity`, `removeLiquidity`, `swapExactTokensForTokens`, `getPrice`, and `getAmountOut`.

### 2.2. Key Public Functions

-   **`addLiquidity(...)`:**
    -   **Parameters:** `tokenA`, `tokenB`, `amountADesired`, `amountBDesired`, `amountAMin`, `amountBMin`, `to`, `deadline`.
    -   **Returns:** `amountA`, `amountB`, `liquidity`.
    -   **Logic:** Allows users to supply liquidity. It calculates the optimal token amounts to maintain the pool's ratio, transfers the tokens, and mints a corresponding amount of LP tokens to the `to` address.

-   **`removeLiquidity(...)`:**
    -   **Parameters:** `tokenA`, `tokenB`, `liquidity`, `amountAMin`, `amountBMin`, `to`, `deadline`.
    -   **Returns:** `amountA`, `amountB`.
    -   **Logic:** Allows users to burn their LP tokens in exchange for their proportional share of the underlying tokens in the pool.

-   **`swapExactTokensForTokens(...)`:**
    -   **Parameters:** `amountIn`, `amountOutMin`, `path`, `to`, `deadline`.
    -   **Logic:** Executes a trade based on the constant product formula. It supports a direct A-to-B swap (`path` length must be 2) and includes slippage protection via `amountOutMin`.

-   **`getReserves(...)` / `getPrice(...)` / `getAmountOut(...)`:** These are view and pure functions that provide essential on-chain data for users and other contracts without consuming gas for state changes.

---

## 3. Key Design Decisions & Technical Challenges üß†

### 3.1. Gas Optimization: `uint112` for Reserves ‚õΩ

A significant optimization technique, inspired by Uniswap V2, is the use of `uint112` instead of `uint256` for storing token reserves (`_reserve0` and `_reserve1`).

-   **Why?** The Ethereum Virtual Machine (EVM) operates on 256-bit (32-byte) storage slots. Using two `uint256` variables would consume two separate slots. However, two `uint112` variables (`112 + 112 = 224` bits) can be **packed** by the Solidity compiler into a single 256-bit slot.
-   **Impact:** When functions like `addLiquidity` or `swapExactTokensForTokens` update both reserves, the EVM performs only **one** `SSTORE` operation instead of two. `SSTORE` is one of the most gas-intensive opcodes, so this packing results in significant gas savings on every liquidity-modifying transaction. A `uint112` is still large enough to represent astronomical quantities of any token.

### 3.2. Decentralized Pair Management: `bytes32` instead of `address` ‚õìÔ∏è

Instead of a centralized `Factory` contract that deploys a new contract `address` for each token pair, `SimpleSwap` uses a more decentralized and lightweight system.

-   **How?** Each token pair is identified by a unique `bytes32` `pairId`. This ID is generated by taking the `keccak256` hash of the two token addresses after they have been deterministically sorted (`_sortTokens`).
-   **Advantages:**
    1.  **Permissionless:** Any pair can exist without being registered in a central contract.
    2.  **Predictable:** The `pairId` can be calculated off-chain, making interactions simpler.
    3.  **Efficiency:** It avoids the gas and complexity associated with deploying new contracts for each pair.

### 3.3. Overcoming "Stack Too Deep" Errors ü§Ø

One of the primary development challenges was encountering the "Stack Too Deep" compilation error in standard environments like Remix IDE without `viaIR` enabled. This error occurs when a function has more than 16 variables (parameters, return values, local variables) on the execution stack at once.

-   **The Problem:** Functions like `addLiquidity` and `removeLiquidity` are naturally complex, requiring many variables to calculate optimal amounts, check slippage, and determine LP token quantities.
-   **The Solution:** The definitive solution was to refactor the code using **explicit local scopes (`{...}`)**.
    -   By wrapping logical sections of the code within curly braces, we signal to the Solidity compiler that any variables declared inside that scope can be cleared from the stack once the block is exited.
    -   This prevents the stack from growing beyond its limit. For example, variables used to calculate the deposit amounts in `addLiquidity` are declared in one scope and are no longer on the stack when variables for calculating LP tokens are needed in the next scope.
-   **Outcome:** This refactoring makes the code robust and ensures it can be compiled and deployed on any standard Solidity toolchain.

---

## 4. Verification & Testing ‚úÖ

The `SimpleSwap` contract was designed to pass a series of on-chain checks executed by an external `SwapVerifier` contract. The process involved:

1.  Deploying the `SimpleSwap` contract and two test ERC20 token contracts (`TestToken.sol`) to the Sepolia testnet.
2.  Deploying the provided `SwapVerifier` contract.
3.  Funding the `SwapVerifier` with the test tokens.
4.  Executing the `verify` function on `SwapVerifier`, which interacts with all of `SimpleSwap`'s core functions to assert correct behavior.

The contract successfully passed all on-chain verification tests in Remix and on the Sepolia testnet.
SimpleSwap address : 0x63de1c0c952Ff0f621A510EBc756819371AAb691
TestToken tokenA address: 0xEC993982Ad62f64Da247bf396868e66a88C69D59
TestToken tokenB address: 0xb68350a0Ca15E9C6e3524c012ef0fA78f2F87d50
SwapVerifier address: 0x9f8F02DAB384DDdf1591C3366069Da3Fb0018220

**A note on source code verification:** To verify the contracts on a block explorer like Etherscan, both the `SimpleSwap` contract and the `TestToken` contracts were **"flattened"** into a single file to resolve all import dependencies. This flattened source code was then used for verification.
